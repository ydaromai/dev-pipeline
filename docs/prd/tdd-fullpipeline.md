# PRD: /tdd-fullpipeline -- Test-Driven Development Pipeline

## Status: DRAFT
## Author: Generated by AI, owned by human
## Date: 2026-03-01

---

## 1. Problem Statement

The existing `/fullpipeline` chains PRD, Dev Plan, JIRA, Execute (Ralph Loop), and Test Verification into a sequential pipeline that works well for general development. However, it produces a recurring defect pattern: **tests that cannot fail**. Because the same agent writes both application code and tests in Stage 4 (`/execute`), the tests confirm what was built rather than what should have been built. This is not a theoretical risk -- it has occurred in production repeatedly:

- **E2E tests with guard clauses that silently pass:** Tests using `if (count > 0)` guards that skip assertions when target elements are not found, causing the test to pass even when the feature is completely absent.
- **Form tests that never render components:** Tests calling `schema.safeParse()` directly on data objects without rendering the React component, validating schema logic but never testing the actual form behavior.
- **Missing `React.forwardRef` silently dropping form values:** A component missing `forwardRef` caused form values to silently disappear on submission. No test caught this because tests were written after the (broken) code, and tested what the code did rather than what the PRD required.

These are not test quality issues fixable by better prompts or stricter critics. They are a structural problem: when code and tests are written together by the same agent in the same context, the tests are shaped by the code rather than by the requirements. The solution is a structural reordering: write tests before code, from requirements and a real UI contract, so that tests define the expected behavior independently.

**Why now:** The pipeline already has the infrastructure for multi-stage orchestration, Ralph Loop iteration, critic review, and human gates. The `/tdd-fullpipeline` reuses this infrastructure in a new order, adding three new capabilities (Design Brief, Mock Analysis, tiered test development) without modifying the existing `/fullpipeline`. The concept was validated by all 10 critics in a Round 2 review with an average score of 7.93/10.

## 2. Target Users

| User | Benefit |
|------|---------|
| **Developers running `/tdd-fullpipeline` on medium/complex features** | Tests that genuinely validate requirements, not just confirm what the agent built. Higher confidence that shipped code meets the PRD. |
| **QA engineers reviewing pipeline output** | Traceability from test plan (TP-{N}) through test code to app code. Clear audit trail for which requirements each test validates. |
| **Pipeline maintainers (contributors to dev-pipeline)** | A parallel pipeline option that reuses existing infrastructure (Ralph Loop, critics, gates) without modifying `/fullpipeline`. |
| **Tech leads deciding pipeline strategy** | Complexity gate to route simple tasks to `/fullpipeline` and reserve TDD overhead for medium/complex work. |

Non-frontend projects should use `/fullpipeline`. The `/tdd-fullpipeline` is designed for projects with `has_frontend: true` where visual UI contracts from mock analysis are most impactful.

## 3. Goals

- **G1: Eliminate "tests that cannot fail"** -- Every test must fail before application code exists. Measured by the self-health gate: `red_count = total_test_count` must pass before Stage 7 (Develop App) begins.
- **G2: Establish requirements-driven test authorship** -- Tier 1 E2E tests are written from PRD + UI contract only, with no access to dev plan or application code. Tier 2 integration/unit tests read the dev plan for component boundaries but still have no access to application code.
- **G3: Provide testable UI contracts from real mock apps** -- Mock Analysis (Stage 3) crawls a working Figma AI mock app with Playwright, extracting DOM structure, interactive elements, ARIA roles, and data-testid candidates from actual component names.
- **G4: Enforce test integrity during app development** -- The test adjustment taxonomy classifies every test change during Stage 7 as Structural (auto-approved), Behavioral (QA re-review required), or Security (immutable). More than 20% adjustments halts the pipeline.
- **G5: Achieve full traceability** -- Every test plan item has a TP-{N} ID. The traceability matrix maps TP-{N} to test file path and test name to pass/fail, bidirectionally. Every dev plan task maps to TP-{N} contracts.
- **G6: Maintain pipeline quality consistency** -- 10-critic Ralph Loop runs at every automated stage, consistent with `/fullpipeline` quality standards.
- **G7: Enable pipeline self-measurement** -- Six metrics emitted to `.pipeline/metrics/{slug}.json` after each run: `red_test_count`, `green_pass_rate`, `test_adjustment_count`, `test_plan_accuracy`, `tdd_cycle_time`, `security_test_integrity`.

## 4. Non-Goals (Explicitly Out of Scope)

- **NG1: Replacing `/fullpipeline`** -- `/tdd-fullpipeline` is a parallel option, not a replacement. The existing `/fullpipeline` is not modified.
- **NG2: Automated Figma integration** -- The Design Brief is handed to a human who uses Figma AI to build the mock app. API-based extraction from Figma is deferred to P2.
- **NG3: Visual regression testing** -- Screenshot comparison between mock app and final app is deferred to P2. Mock screenshots are used for contract extraction, not pixel-level comparison.
- **NG4: New critic agents** -- All 10 existing critics are reused. No new critic personas are created.
- **NG5: Runtime code or services** -- The pipeline is Markdown command files and YAML config. No JavaScript runtime, no database, no API server.
- **NG6: Modifying existing critic persona files** -- Critic `.md` files remain unchanged. The pipeline uses them as-is.
- **NG7: Full CI integration** -- Label-based skip on `tdd/{slug}/tests` branches is a P0 convention documented in the command file, not a CI system integration.
- **NG8: TDD for simple tasks** -- Config changes, documentation updates, and small single-file edits use `/fullpipeline`. The complexity gate routes only medium/complex tasks to `/tdd-fullpipeline`.

## 5. User Stories (with inline AC)

### US-1: Run TDD full pipeline end-to-end

**As a** developer with a medium or complex feature requirement, **I want** to run `/tdd-fullpipeline <requirement>` and have it orchestrate all 8 stages with gates between each, **so that** I get a fully implemented feature where tests were written and verified before application code.

**Acceptance Criteria:**
- [ ] AC 1.1: `/tdd-fullpipeline` command file exists at `commands/tdd-fullpipeline.md` and follows the same orchestrator pattern as `fullpipeline.md` (fresh-context subagents, orchestrator state, gates).
- [ ] AC 1.2: The orchestrator chains 8 stages in order: PRD, Design Brief, Mock Analysis, Test Plan, Dev Plan, Develop Tests, Develop App, Validate.
- [ ] AC 1.3: Each automated stage runs in a fresh-context subagent (Task tool, model: opus).
- [ ] AC 1.4: The orchestrator state includes: `slug`, `prd_path`, `plan_path`, `brief_path`, `contract_path`, `test_plan_path`, `test_result`, `requirement`, `user_prefs`.
- [ ] AC 1.5: Error recovery section covers all 8 stages with re-run instructions.
- [ ] AC 1.6: The completion report includes all 8 stage results, the traceability matrix summary, and pipeline metrics.
- [ ] AC 1.7: The `slug` value is validated at orchestrator startup to match the pattern `^[a-z0-9][a-z0-9_-]{0,63}$`. Slugs containing `/`, `\`, `..`, or null bytes are rejected before any file path is constructed.
- [ ] AC 1.8: Before Stage 1 begins, the orchestrator captures the current test suite results as a baseline by running the project's test command and persisting results to `.pipeline/tdd/<slug>/baseline-results.json`. If no tests exist yet, the baseline is recorded as empty. This baseline is used by AC 9.4 (regression check). The baseline results file follows the schema: `{ tests: [{ name: string, file: string, status: 'pass' | 'fail' | 'skip' }], captured_at: ISO8601, total: number, passed: number, failed: number, skipped: number }`. If no tests exist yet, the file contains `{ tests: [], captured_at: ISO8601, total: 0, passed: 0, failed: 0, skipped: 0 }`.
- [ ] AC 1.9: At pipeline startup (before Stage 1), the orchestrator verifies Playwright is installed by running `npx playwright --version`. If Playwright is not available, the pipeline halts with an error message including installation instructions. This prevents wasting time on Stages 1-2 before discovering a Stage 3 blocker. The installed Playwright version is verified to be >= 1.40. If the version is below minimum, the pipeline halts with an error message including the required minimum version.
- [ ] AC 1.10: When a pipeline run is aborted (user chooses abort at any gate, or pipeline fails unrecoverably), the orchestrator logs the list of residual artifacts (branches, directories, partial files) created during the run. The user can clean up manually or re-run the pipeline to resume from the last completed stage.
- [ ] AC 1.11: Before Stage 1 proceeds, the orchestrator verifies that `.pipeline/tdd/` and `.pipeline/metrics/` entries exist in `.gitignore`. If `.gitignore` does not exist, it is created. If the entries are already present, no duplicate entries are added (idempotent).

### US-2: Generate PRD (Stage 1)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 1 to generate a PRD using the same `/req2prd` process as `/fullpipeline`, **so that** the TDD pipeline starts from the same requirements foundation.

**Acceptance Criteria:**
- [ ] AC 2.1: Stage 1 spawns a subagent that reads and executes `${CLAUDE_PLUGIN_ROOT}/commands/req2prd.md`.
- [ ] AC 2.2: The PRD is saved to `docs/prd/<slug>.md` using the standard 14-section template.
- [ ] AC 2.3: The scoring Ralph Loop runs all applicable critics (per-critic > 8.5, overall > 9.0, max 5 iterations).
- [ ] AC 2.4: Gate 1 presents critic scores and requires user approval before proceeding.

### US-3: Generate Design Brief (Stage 2)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 2 to generate a Design Brief from the approved PRD that can be given to a Figma AI designer, **so that** a working mock app is built from structured functional requirements rather than ad-hoc interpretation.

**Acceptance Criteria:**
- [ ] AC 3.1: The Design Brief command file exists at `commands/tdd-design-brief.md`.
- [ ] AC 3.2: The Design Brief reads the approved PRD and extracts: route manifest listing all expected routes with their paths and descriptions, user flows (step-by-step with entry/exit points), component inventory (name, purpose, data inputs, interactive elements), data shapes (fields, types, validation rules, example values), responsive requirements (mobile/tablet/desktop behavior), and accessibility requirements (WCAG 2.1 AA, keyboard nav, screen reader expectations).
- [ ] AC 3.3: The Design Brief does NOT prescribe layouts, colors, spacing, typography, or visual hierarchy -- these are left to the AI designer's creative decisions.
- [ ] AC 3.4: The Design Brief output is saved to `docs/tdd/<slug>/design-brief.md`.
- [ ] AC 3.5: The Design Brief includes a "Mock App Requirements" section specifying that the mock must be a functional, navigable app (not static images) with all routes, interactive elements, and form validation implemented.
- [ ] AC 3.6: A 10-critic Ralph Loop reviews the Design Brief (max 5 iterations, 0 Critical + 0 Warnings).
- [ ] AC 3.7: Gate 2 is a MANUAL gate -- the user takes the Design Brief to Figma AI, builds the mock app, deploys it (or runs it locally), and provides the mock app URL to the pipeline.

### US-4: Analyze mock app and extract UI contract (Stage 3)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 3 to crawl the working mock app with Playwright and extract a structured UI contract, **so that** tests can be written against the real DOM structure instead of guessing at selectors and component hierarchies.

**Acceptance Criteria:**
- [ ] AC 4.1: The Mock Analysis command file exists at `commands/tdd-mock-analysis.md`.
- [ ] AC 4.2: The command accepts a mock app URL as input (provided by the user at Gate 2). The URL is validated to use `http://` or `https://` scheme only. URLs using `file://`, `data:`, `javascript:`, or private network ranges (RFC 1918) outside of loopback are rejected with a clear error message. Accepted loopback addresses: `localhost`, `127.0.0.0/8`, `::1`, `0.0.0.0`. All other RFC 1918 ranges (`10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) are rejected. No port restriction is applied; connections to non-HTTP ports are handled by the per-route navigation timeout (NFR-7, 15 seconds).
- [ ] AC 4.3: Playwright navigates all discoverable routes in the mock app (link traversal from entry page, capped at `tdd.max_mock_routes`, default: 20).
- [ ] AC 4.4: At each route, Playwright captures screenshots at 3 viewports: mobile (375x812), tablet (768x1024), desktop (1280x720).
- [ ] AC 4.5: At each route, the analysis extracts: DOM structure (component tree, nesting depth), interactive elements (buttons, links, inputs, selects, textareas), form fields (name, type, required, validation), ARIA roles and labels, tab order and focus management, `data-testid` candidates derived from component names in the DOM. Data-testid candidates are derived from DOM element roles and labels using the convention: `kebab-case` of the accessible name or component purpose (e.g., `submit-button`, `supplier-name-input`, `navigation-menu`). Duplicate candidates within the same route are disambiguated by appending the parent component context. Elements with no accessible name and no component name use the fallback convention `{element-type}-{sequential-index}` (e.g., `div-3`, `button-7`). Such elements are logged as Warnings in the UI contract.
- [ ] AC 4.6: Keyboard navigation paths are tested: Tab through all interactive elements, verify focus visibility, test Enter/Space activation.
- [ ] AC 4.7: The output is a structured UI contract document saved to `docs/tdd/<slug>/ui-contract.md` with sections: Route Map, Component Inventory, Interactive Elements, Form Contracts, Accessibility Map, Data-Testid Registry, Screenshots (paths).
- [ ] AC 4.8: Screenshots are saved to `.pipeline/tdd/<slug>/mock-screenshots/`.
- [ ] AC 4.9: A 10-critic Ralph Loop reviews the UI contract (max 5 iterations, 0 Critical + 0 Warnings).
- [ ] AC 4.10: Gate 3 presents the extracted contract summary and requires user approval. The user can correct any misidentified elements or missing routes before proceeding.
- [ ] AC 4.11: After Mock Analysis completes, Gate 3 cross-references the extracted UI contract against the Design Brief's route manifest and Mock App Requirements section. Routes present in the manifest but missing from the extracted contract are flagged as Warnings. Interactive elements specified in the component inventory but not found in the DOM are flagged as Warnings.
- [ ] AC 4.12: The UI contract document must not exceed 50,000 characters. If the extracted content exceeds this limit, routes are truncated from the end (lowest-priority routes first) with a Warning noting the truncation and the count of routes dropped.

### US-5: Generate test plan from PRD and UI contract (Stage 4)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 4 to generate a comprehensive test plan from the PRD and the UI contract, **so that** every testable requirement has a specific, traceable test specification before any code is written.

**Acceptance Criteria:**
- [ ] AC 5.1: The Test Plan command file exists at `commands/tdd-test-plan.md`.
- [ ] AC 5.2: The test plan reads the PRD, the UI contract from Stage 3, and any schema files referenced in the PRD.
- [ ] AC 5.3: The test plan produces two tiers of test specifications:
  - Tier 1 (E2E/Playwright): Full specifications from PRD + UI contract.
  - Tier 2 (integration/unit): Specification outlines only (TP-{N} ID, requirement citation, test intent description). Full test code is developed in Stage 7 alongside application code.
- [ ] AC 5.4: Every test specification has a unique traceability ID: `TP-{N}` (e.g., TP-1, TP-2, ..., TP-N).
- [ ] AC 5.5: The test plan includes four mandatory contract sections: Performance Contracts, Accessibility Contracts, Error Contracts, Data Flow Contracts.
- [ ] AC 5.6: The test plan output is saved to `docs/tdd/<slug>/test-plan.md`.
- [ ] AC 5.7: A 10-critic Ralph Loop reviews the test plan (max 5 iterations, 0 Critical + 0 Warnings).
- [ ] AC 5.8: Gate 4 presents the test plan summary (TP count by tier, contract coverage) and requires user approval.
- [ ] AC 5.9: Tier 2 specification outlines in the test plan must include at minimum: TP-{N} ID, tier label (`Tier 2`), linked PRD requirement (AC reference), test intent description (one sentence), and expected test type (integration or unit). This provides sufficient structure for Stage 7 to implement the full test.

### US-6: Generate dev plan with contract negotiation (Stage 5)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 5 to generate a dev plan from the PRD and test plan, with a contract negotiation gate when conflicts arise, **so that** the dev plan respects the test contracts as the authority document for UI behavior.

**Acceptance Criteria:**
- [ ] AC 6.1: Stage 5 uses the same dev plan generation process as `/prd2plan` (Epic/Story/Task/Subtask breakdown with dependency graph).
- [ ] AC 6.2: The dev plan reads both the PRD and the test plan. Every task maps to one or more `TP-{N}` contracts from the test plan.
- [ ] AC 6.3: After initial dev plan generation, the Contract Negotiation Gate runs: the pipeline compares dev plan architecture decisions against test plan contracts. If a dev plan task proposes an approach that would invalidate a test contract (e.g., different component boundaries, different data flow, different route structure), the conflict is flagged.
- [ ] AC 6.4: For each conflict, the pipeline presents: the conflicting TP-{N} contract, the dev plan proposal, and a recommended resolution. The test plan is the authority document -- the dev plan adjusts unless the user explicitly overrides.
- [ ] AC 6.5: After conflict resolution, Tier 2 test specifications (integration/unit) in the test plan are completed with component boundaries and internal architecture from the dev plan.
- [ ] AC 6.6: A 10-critic Ralph Loop reviews the dev plan (max 5 iterations, 0 Critical + 0 Warnings).
- [ ] AC 6.7: Gate 5 presents the dev plan summary, conflict resolution log (if any), and requires user approval.

### US-7: Develop tests with tiered development and self-health gate (Stage 6)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 6 to develop Tier 1 E2E tests with a self-health gate verifying all tests fail before any app code exists, **so that** every test is proven to detect the absence of the feature it validates.

**Acceptance Criteria:**
- [ ] AC 7.1: The Develop Tests command file exists at `commands/tdd-develop-tests.md`.
- [ ] AC 7.2: Tier 1 E2E tests are developed by a "blind agent" -- the subagent receives the PRD, UI contract, schema files, and test plan, but NOT the dev plan and NOT any application code. This ensures E2E tests test requirements, not implementation.
- [ ] AC 7.3: Tier 2 integration/unit tests are developed in Stage 7 (Develop App) by a subagent that receives the PRD, UI contract, test plan, AND the dev plan. Tier 2 tests are written alongside the application code for each task, guided by the Tier 2 specifications from the test plan.
- [ ] AC 7.4: Each test maps to a `TP-{N}` traceability ID from the test plan.
- [ ] AC 7.5: A 10-critic Ralph Loop reviews the test code (max 5 iterations, 0 Critical + 0 Warnings).
- [ ] AC 7.6: After all tests are written, the self-health gate runs: execute all tests and verify `red_count = total_test_count`. Every test must fail (red) because no application code exists yet. A test is considered "passing" if it exits with code 0 and evaluates at least one assertion. Tests that exit with code 0 but contain no assertions are flagged as fake tests (same as AC 7.7).
- [ ] AC 7.7: If any test passes before app code exists, the pipeline identifies it as a "fake test" and flags it as a Critical finding. The failing test must be fixed or removed before proceeding.
- [ ] AC 7.8: Gate 6 presents: total test count, red count, any fake tests identified, and requires user approval.
- [ ] AC 7.9: Tests are committed to a `tdd/{slug}/tests` branch.
- [ ] AC 7.10: If the self-health gate fails (some tests pass without app code), the pipeline enters a fix loop: the failing (green) tests are sent to a fix subagent with instructions to make them properly assert behavior that requires application code. After fixes, the self-health gate re-runs. Maximum 3 fix iterations; then escalate to the user with a list of fake tests that could not be fixed.

### US-8: Develop app with test adjustment taxonomy (Stage 7)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 7 to implement the application code using the Ralph Loop, with strict rules about when and how tests can be adjusted, **so that** test integrity is maintained while allowing necessary structural changes.

**Acceptance Criteria:**
- [ ] AC 8.1: Stage 7 uses the same execution pattern as `/execute` (read dev plan, build dependency graph, Ralph Loop per task).
- [ ] AC 8.2: When a task requires test changes, each change is classified using the test adjustment taxonomy:
  - **Structural** (import paths, file locations, test setup/teardown, fixture updates): Auto-approved, no review required.
  - **Behavioral** (assertion logic, expected values, test flow, selector changes): Requires QA critic re-review with citation of the affected `TP-{N}` contract and justification.
  - **Security** (authentication tests, authorization tests, input validation tests, CSRF/XSS tests): Immutable. Cannot be changed by the app development agent. If a security test fails, the app code must change, not the test.
- [ ] AC 8.3: If more than 20% of Tier 1 E2E test assertions are behaviorally adjusted during Stage 7, the pipeline halts and escalates to the user with a report of all adjustments made. Structural adjustments (import paths, setup) are excluded from the threshold count. The denominator is the total number of Tier 1 E2E assertions as counted at the Stage 6 self-health gate. This threshold is configurable via `tdd.max_test_adjustment_pct` (default: 20).
- [ ] AC 8.4: A 10-critic Ralph Loop reviews each task (max 3 iterations per task, escalate to user).
- [ ] AC 8.5: Gate 7 is per-PR approval, same as `/execute` Gate 4.
- [ ] AC 8.6: A test is automatically classified as Security tier if its description or file path contains any of the following keywords: `auth`, `login`, `logout`, `permission`, `role`, `csrf`, `xss`, `injection`, `sanitize`, `authorization`, `token`, `session`, `cors`, `encrypt`, `certificate`, `rate-limit`. Automatic classification overrides manual classification. The Security Critic validates Security-tier classification coverage during Stage 6 critic review. Tests in files under a `security/` or `__tests__/security/` directory path are automatically classified as Security tier regardless of name.
- [ ] AC 8.7: The QA Critic in the Stage 7 Ralph Loop explicitly audits test adjustment classifications against the diff. Any change to an `expect()` call, assertion value, or test boundary condition is flagged as Behavioral regardless of the agent's self-classification.

### US-9: Validate with traceability and metrics (Stage 8)

**As a** developer running `/tdd-fullpipeline`, **I want** Stage 8 to run a comprehensive validation including smoke tests, traceability matrix, regression check, and metrics emission, **so that** I have confidence the feature works correctly and full audit trail of what was tested.

**Acceptance Criteria:**
- [ ] AC 9.1: Smoke test runs using the same infrastructure as `/execute` Step 5 (dev server startup, health checks, core user flow, browser screenshots if `has_frontend: true`).
- [ ] AC 9.2: Traceability matrix is generated mapping every `TP-{N}` to: test file path, test name (describe/it block path), and pass/fail status. The matrix is bidirectional -- from TP-{N} to test name, and from test name to TP-{N}. Test names (not line numbers) are used as the primary identifier to survive file restructuring during Stage 7. The traceability key is `{file_path}::{describe/it block path}` to guarantee cross-file uniqueness.
- [ ] AC 9.3: Any `TP-{N}` without a corresponding passing test is flagged as a gap.
- [ ] AC 9.4: Regression check runs the full test suite and diffs results against the pre-pipeline baseline (test results before the TDD pipeline started).
- [ ] AC 9.5: A 10-critic cumulative validation runs on the `main..HEAD` diff (max 3 iterations, escalate to user).
- [ ] AC 9.6: Pipeline metrics are emitted to `.pipeline/metrics/{slug}.json` with the following 6 metrics: `red_test_count` (tests that were red at self-health gate), `green_pass_rate` (percentage of tests passing after app development), `test_adjustment_count` (total test adjustments during Stage 7, broken down by type), `test_plan_accuracy` (percentage of TP-{N} items that passed without behavioral test adjustment), `tdd_cycle_time` (wall-clock time from Stage 4 start to Stage 8 completion), `security_test_integrity` (percentage of security tests that were never modified).
- [ ] AC 9.7: Gate 8 (final gate) presents: smoke test results, traceability matrix summary, regression check results, metrics summary, overall verdict (PASS/FAIL).

### US-10: Route simple tasks to standard pipeline via complexity gate

**As a** developer, **I want** the pipeline to recognize when a task is too simple for TDD overhead (config changes, docs, small edits), **so that** I use `/fullpipeline` for simple work and `/tdd-fullpipeline` only when the structural benefits justify the extra stages.

**Acceptance Criteria:**
- [ ] AC 10.1: The `tdd-fullpipeline.md` command file includes a complexity assessment in Stage 1 (after PRD generation) that evaluates the PRD scope.
- [ ] AC 10.2: If the PRD scope is assessed as Simple (based on: single-file changes, config-only, documentation-only, no UI components, no data flow changes), the pipeline recommends switching to `/fullpipeline` with a clear message explaining why.
- [ ] AC 10.3: The user can override the recommendation and continue with `/tdd-fullpipeline` if they choose.
- [ ] AC 10.4: The complexity assessment criteria are documented in the command file (not hardcoded magic values).

### US-11: Configure TDD pipeline via pipeline-config-template.yaml

**As a** pipeline maintainer, **I want** a `tdd` section in the pipeline config template with all TDD-specific settings, **so that** teams can customize TDD behavior per project.

**Acceptance Criteria:**
- [ ] AC 11.1: `pipeline-config-template.yaml` contains a `tdd` section (commented out, matching existing pattern) with fields for: `max_mock_routes` (default: 20), `self_health_gate` (default: true), `max_test_adjustment_pct` (default: 20), `metrics_dir` (default: ".pipeline/metrics"), `tests_branch_pattern` (default: "tdd/{slug}/tests").
- [ ] AC 11.2: The `tdd` section is placed after the `test_stage` section.
- [ ] AC 11.3: The `tdd` section includes a `tdd_stages` subsection for stage-specific critic overrides, following the same pattern as `validation.stages`.
- [ ] AC 11.4: Default values are documented inline with comments explaining each option.

### US-12: Skip red tests in CI on TDD test branches

**As a** developer with TDD test branches, **I want** a documented CI strategy for skipping test runs on `tdd/{slug}/tests` branches, **so that** intentionally-red tests do not break CI before application code is written.

**Acceptance Criteria:**
- [ ] AC 12.1: The `tdd-fullpipeline.md` command file documents the label-based CI skip convention: branches matching `tdd/{slug}/tests` should be labeled `tdd-red-tests` to signal CI that test failures are expected.
- [ ] AC 12.2: The documentation includes example GitHub Actions workflow snippets showing how to conditionally skip test jobs based on branch name pattern or label.
- [ ] AC 12.3: The `tdd-develop-tests.md` command file applies the label when creating the tests branch/PR.

### US-13: Update documentation for TDD pipeline

**As a** pipeline user or maintainer, **I want** WORKFLOW.md and README.md updated to describe the TDD pipeline option, **so that** I can discover and understand the TDD pipeline alongside the existing pipeline.

**Acceptance Criteria:**
- [ ] AC 13.1: WORKFLOW.md includes a new section for `/tdd-fullpipeline` describing the 8-stage flow, positioned after the existing `/fullpipeline` stages.
- [ ] AC 13.2: WORKFLOW.md describes each TDD-specific stage (Design Brief, Mock Analysis, Test Plan, Develop Tests) with workflow detail tables matching the format of existing stages.
- [ ] AC 13.3: WORKFLOW.md Quick Reference table includes `/tdd-fullpipeline` with input, output, and human gates.
- [ ] AC 13.4: README.md flow diagram or commands table includes `/tdd-fullpipeline`.

### US-14: Structural validation tests for TDD pipeline

**As a** pipeline maintainer, **I want** structural validation tests that verify TDD pipeline command files contain required content, **so that** accidental regressions are caught by CI.

**Acceptance Criteria:**
- [ ] AC 14.1: A test file `test/tdd-pipeline-structure.test.js` exists, following the same pattern as `test/test-stage-structure.test.js`.
- [ ] AC 14.2: Tests verify `tdd-fullpipeline.md` has all 8 stage sections, gates, orchestrator state with TDD-specific fields, error recovery for all 8 stages, and completion report.
- [ ] AC 14.3: Tests verify `tdd-design-brief.md` references the PRD, outputs to `docs/tdd/<slug>/design-brief.md`, includes Mock App Requirements section, and runs critic review.
- [ ] AC 14.4: Tests verify `tdd-mock-analysis.md` references Playwright, 3 viewport widths (375, 768, 1280), outputs to `docs/tdd/<slug>/ui-contract.md`, and extracts DOM structure, ARIA roles, and data-testid candidates.
- [ ] AC 14.5: Tests verify `tdd-test-plan.md` references TP-{N} traceability IDs, includes Performance Contracts / Accessibility Contracts / Error Contracts / Data Flow Contracts sections, and outputs tiered specifications.
- [ ] AC 14.6: Tests verify `tdd-develop-tests.md` references self-health gate (`red_count = total_test_count`), tiered development (Tier 1 / Tier 2), and blind agent context restrictions.
- [ ] AC 14.7: Tests verify `pipeline-config-template.yaml` has a `tdd` section with `max_mock_routes`, `self_health_gate`, `max_test_adjustment_pct`, `metrics_dir`.
- [ ] AC 14.8: Tests verify cross-file consistency: `tdd-fullpipeline.md` references all TDD stage command files, config keys match between command files and config template.

## 6. Functional Requirements (P0/P1/P2)

### Must Have (P0)

- **FR-1:** Create `commands/tdd-fullpipeline.md` -- 8-stage orchestrator command file with fresh-context subagents, orchestrator state, gates between each stage, error recovery, and completion report. (US-1)
- **FR-2:** Stage 1 (PRD) reuses `commands/req2prd.md` via subagent, identical to `/fullpipeline` Stage 1. (US-2)
- **FR-3:** Create `commands/tdd-design-brief.md` -- Stage 2 command file that reads the PRD and generates a functional requirements brief for Figma AI designer, including user flows, component inventory, data shapes, responsive requirements, accessibility requirements, and Mock App Requirements section. Does not prescribe visual design decisions. (US-3)
- **FR-4:** Create `commands/tdd-mock-analysis.md` -- Stage 3 command file that accepts a mock app URL, crawls all routes with Playwright, captures screenshots at 3 viewports, extracts DOM structure, interactive elements, form fields, ARIA roles, tab order, data-testid candidates, and keyboard navigation paths. Outputs structured UI contract to `docs/tdd/<slug>/ui-contract.md`. (US-4)
- **FR-5:** Create `commands/tdd-test-plan.md` -- Stage 4 command file that reads PRD + UI contract + schema files and generates tiered test specifications (Tier 1 E2E from PRD + UI contract, Tier 2 placeholders for post-dev-plan). Every test item has a TP-{N} traceability ID. Includes mandatory sections: Performance Contracts, Accessibility Contracts, Error Contracts, Data Flow Contracts. (US-5)
- **FR-6:** Stage 5 (Dev Plan) reuses the `/prd2plan` generation process, extended with contract negotiation gate -- compares dev plan against test plan contracts, flags conflicts, resolves with test plan as authority document. After resolution, completes Tier 2 test specifications with component boundaries. (US-6)
- **FR-7:** Create `commands/tdd-develop-tests.md` -- Stage 6 command file implementing Tier 1 E2E test development only: Tier 1 E2E by blind agent (PRD + UI contract + schema, no dev plan, no app code). Each test maps to TP-{N}. Self-health blocking gate: `red_count = total_test_count`. Tier 2 integration/unit tests are developed in Stage 7 alongside application code. (US-7)
- **FR-8:** Stage 7 (Develop App) reuses the `/execute` execution pattern, extended with test adjustment taxonomy -- Structural (auto-approved), Behavioral (QA re-review with TP-{N} citation), Security (immutable). More than 20% adjustments halts pipeline. (US-8)
- **FR-9:** Stage 8 (Validate) -- Smoke test (same as `/execute` Step 5), traceability matrix (TP-{N} to test file path and test name to pass/fail, bidirectional), regression check (full suite diff against baseline), 10-critic cumulative validation on `main..HEAD`. (US-9)
- **FR-10:** Self-health gate implementation -- After all tests are written (Stage 6), run the full test suite and assert `red_count = total_test_count`. If any test passes without app code, flag as "fake test" (Critical). This is a BLOCKING gate: Stage 7 cannot start until it passes. (US-7)
- **FR-11:** Contract negotiation gate implementation -- Between dev plan generation and test development. When dev plan architecture conflicts with test plan contracts, structured resolution with test plan as authority. (US-6)
- **FR-12:** 10-critic Ralph Loop at every automated stage -- Design Brief, Mock Analysis (UI contract), Test Plan, Dev Plan, Develop Tests, Develop App (per task), Validate (cumulative). (US-1 through US-9)
- **FR-14:** CI strategy documentation -- Label-based skip on `tdd/{slug}/tests` branches with GitHub Actions workflow examples. The CI skip convention is required on the first pipeline use when red tests are pushed. (US-12)

### Should Have (P1)

- **FR-13:** Pipeline metrics emission to `.pipeline/metrics/{slug}.json` with 6 metrics: `red_test_count`, `green_pass_rate`, `test_adjustment_count`, `test_plan_accuracy`, `tdd_cycle_time`, `security_test_integrity`. (US-9)
- **FR-15:** Complexity gate in Stage 1 -- After PRD generation, assess scope complexity. Recommend `/fullpipeline` for Simple tasks. User can override. (US-10)
- **FR-16:** Config template updates -- `tdd` section in `pipeline-config-template.yaml` with `max_mock_routes`, `self_health_gate`, `max_test_adjustment_pct`, `metrics_dir`, `tests_branch_pattern`. (US-11)
- **FR-17:** Documentation updates -- WORKFLOW.md TDD pipeline section with 8-stage flow, stage detail tables, Quick Reference entry. README.md commands table update. (US-13)
- **FR-20:** Structural validation tests in `test/tdd-pipeline-structure.test.js` covering all TDD command files, config entries, and cross-file consistency. (US-14)

### Nice to Have (P2)

- **FR-18:** Visual regression testing -- Screenshot comparison between mock app screenshots (Stage 3) and final app screenshots (Stage 8) to detect visual deviations. (NG3 deferred)
- **FR-19:** Automated Figma integration -- API-based mock app extraction instead of manual handoff at Gate 2. (NG2 deferred)

## 7. Acceptance Criteria (Consolidated)

### P0 -- Must Pass for Launch

- [ ] AC 1.1: `commands/tdd-fullpipeline.md` exists with orchestrator pattern
- [ ] AC 1.2: 8 stages chained in order with gates
- [ ] AC 1.3: Fresh-context subagent per automated stage
- [ ] AC 1.4: Orchestrator state includes all TDD-specific fields
- [ ] AC 1.5: Error recovery covers all 8 stages
- [ ] AC 1.6: Completion report includes all 8 stage results, traceability, metrics
- [ ] AC 1.7: Slug validated against `^[a-z0-9][a-z0-9_-]{0,63}$` at startup
- [ ] AC 1.8: Baseline test results captured before Stage 1
- [ ] AC 1.9: Playwright pre-flight check at startup (version >= 1.40)
- [ ] AC 1.10: Pipeline abort logs residual artifacts for cleanup
- [ ] AC 1.11: Idempotent `.gitignore` verification for `.pipeline/tdd/` and `.pipeline/metrics/`
- [ ] AC 2.1: Stage 1 reuses `/req2prd` via subagent
- [ ] AC 2.2: PRD saved to standard path
- [ ] AC 2.3: Scoring Ralph Loop with thresholds
- [ ] AC 2.4: Gate 1 with critic scores and approval
- [ ] AC 3.1: `commands/tdd-design-brief.md` exists
- [ ] AC 3.2: Design Brief extracts route manifest, user flows, component inventory, data shapes, responsive/accessibility requirements
- [ ] AC 3.3: No visual design prescriptions (layouts, colors, spacing)
- [ ] AC 3.4: Output saved to `docs/tdd/<slug>/design-brief.md`
- [ ] AC 3.5: Mock App Requirements section present
- [ ] AC 3.6: 10-critic Ralph Loop on Design Brief
- [ ] AC 3.7: Gate 2 is MANUAL (user builds mock, provides URL)
- [ ] AC 4.1: `commands/tdd-mock-analysis.md` exists
- [ ] AC 4.2: Accepts mock app URL as input with scheme validation
- [ ] AC 4.3: Navigates all discoverable routes (capped at `max_mock_routes`)
- [ ] AC 4.4: Screenshots at 3 viewports per route
- [ ] AC 4.5: Extracts DOM structure, interactive elements, forms, ARIA, tab order, data-testid
- [ ] AC 4.6: Keyboard navigation testing
- [ ] AC 4.7: UI contract output to `docs/tdd/<slug>/ui-contract.md`
- [ ] AC 4.8: Screenshots saved to `.pipeline/tdd/<slug>/mock-screenshots/`
- [ ] AC 4.9: 10-critic Ralph Loop on UI contract
- [ ] AC 4.10: Gate 3 with contract summary and user approval
- [ ] AC 4.11: Gate 3 cross-references UI contract against Design Brief route manifest and component inventory
- [ ] AC 4.12: UI contract document capped at 50,000 characters (lowest-priority routes truncated with Warning)
- [ ] AC 5.1: `commands/tdd-test-plan.md` exists
- [ ] AC 5.2: Reads PRD + UI contract + schema files
- [ ] AC 5.3: Tiered specifications (Tier 1 full specs, Tier 2 outlines only)
- [ ] AC 5.4: TP-{N} traceability IDs on every test item
- [ ] AC 5.5: Mandatory sections: Performance, Accessibility, Error, Data Flow Contracts
- [ ] AC 5.6: Output saved to `docs/tdd/<slug>/test-plan.md`
- [ ] AC 5.7: 10-critic Ralph Loop on test plan
- [ ] AC 5.8: Gate 4 with test plan summary and approval
- [ ] AC 5.9: Tier 2 specification outlines include TP-{N} ID, tier label, AC reference, intent, test type
- [ ] AC 6.1: Dev plan generation reuses `/prd2plan` process
- [ ] AC 6.2: Every task maps to TP-{N} contracts
- [ ] AC 6.3: Contract negotiation gate compares dev plan vs test plan contracts
- [ ] AC 6.4: Conflict resolution with test plan as authority
- [ ] AC 6.5: Tier 2 specifications completed after dev plan
- [ ] AC 6.6: 10-critic Ralph Loop on dev plan
- [ ] AC 6.7: Gate 5 with conflict resolution log and approval
- [ ] AC 7.1: `commands/tdd-develop-tests.md` exists
- [ ] AC 7.2: Tier 1 E2E by blind agent (no dev plan, no app code)
- [ ] AC 7.3: Tier 2 integration/unit developed in Stage 7 alongside app code
- [ ] AC 7.4: Tests map to TP-{N} IDs
- [ ] AC 7.5: 10-critic Ralph Loop on test code
- [ ] AC 7.6: Self-health gate: `red_count = total_test_count`
- [ ] AC 7.7: Fake tests flagged as Critical
- [ ] AC 7.8: Gate 6 with red count and approval
- [ ] AC 7.9: Tests committed to `tdd/{slug}/tests` branch
- [ ] AC 7.10: Self-health gate fix loop (max 3 iterations, then escalate)
- [ ] AC 8.1: Stage 7 reuses `/execute` execution pattern
- [ ] AC 8.2: Test adjustment taxonomy (Structural, Behavioral, Security)
- [ ] AC 8.3: >20% behavioral Tier 1 E2E adjustment threshold halts pipeline (configurable)
- [ ] AC 8.4: 10-critic Ralph Loop per task
- [ ] AC 8.5: Per-PR approval (Gate 7)
- [ ] AC 8.6: Security test auto-classification by keyword matching (expanded keyword list + directory-based classification)
- [ ] AC 8.7: QA Critic audits test adjustment classifications against diff (expect/assertion changes flagged Behavioral)
- [ ] AC 9.1: Smoke test using `/execute` Step 5 infrastructure
- [ ] AC 9.2: Traceability matrix: TP-{N} to test name to pass/fail (bidirectional, test names not line numbers)
- [ ] AC 9.3: Gaps flagged for TP-{N} without passing test
- [ ] AC 9.5: 10-critic cumulative validation on `main..HEAD`
- [ ] AC 9.7: Gate 8 with full results and overall verdict
- [ ] AC 12.1: CI skip convention documented in `tdd-fullpipeline.md` (required on first pipeline use when red tests are pushed)
- [ ] AC 12.2: GitHub Actions workflow examples included
- [ ] AC 12.3: Label applied when creating tests branch

### P1 -- Should Pass for Launch

- [ ] AC 9.4: Regression check against pre-pipeline baseline
- [ ] AC 9.6: Metrics emitted to `.pipeline/metrics/{slug}.json`
- [ ] AC 10.1: Complexity assessment in Stage 1
- [ ] AC 10.2: Simple scope recommends `/fullpipeline`
- [ ] AC 10.3: User can override complexity recommendation
- [ ] AC 10.4: Complexity criteria documented in command file
- [ ] AC 11.1: `tdd` section in config template with all fields
- [ ] AC 11.2: `tdd` section placed after `test_stage`
- [ ] AC 11.3: `tdd_stages` subsection for critic overrides
- [ ] AC 11.4: Default values documented inline
- [ ] AC 13.1: WORKFLOW.md TDD section present
- [ ] AC 13.2: TDD stage detail tables in WORKFLOW.md
- [ ] AC 13.3: Quick Reference table includes `/tdd-fullpipeline`
- [ ] AC 13.4: README.md includes `/tdd-fullpipeline`
- [ ] AC 14.1: `test/tdd-pipeline-structure.test.js` exists
- [ ] AC 14.2: Tests cover `tdd-fullpipeline.md` structure
- [ ] AC 14.3: Tests cover `tdd-design-brief.md` content
- [ ] AC 14.4: Tests cover `tdd-mock-analysis.md` content
- [ ] AC 14.5: Tests cover `tdd-test-plan.md` content
- [ ] AC 14.6: Tests cover `tdd-develop-tests.md` content
- [ ] AC 14.7: Tests cover config template `tdd` section
- [ ] AC 14.8: Tests cover cross-file consistency

## 8. Non-Functional Requirements

### Consistency

- **NFR-1:** All TDD command files must follow the same `.md` command pattern as existing commands (`execute.md`, `test.md`, `fullpipeline.md`): heading structure, subagent prompts, critic invocation, PR creation, human gates.
- **NFR-2:** The `/tdd-fullpipeline` orchestrator must follow the same fresh-context subagent pattern as `/fullpipeline`: orchestrator carries only file paths and user decisions, each stage runs in a fresh subagent, all artifacts persisted on disk.

### Isolation

- **NFR-3:** The existing `/fullpipeline` must not be modified. Zero behavioral changes to any existing command file or config template (except the config template, which receives an additive `tdd` section).
- **NFR-4:** Tier 1 E2E test development (Stage 6) must be context-isolated: the blind agent subagent receives only PRD + UI contract + schema files. The subagent prompt must NOT reference the dev plan path or any application code paths.

### Reliability

- **NFR-5:** The self-health gate must be deterministic -- running the same tests against the same (empty) codebase must produce the same red count. Flaky tests that intermittently pass must be caught and flagged.
- **NFR-6:** Mock Analysis (Stage 3) must handle mock app failures gracefully: if a route fails to load, log a Warning and continue to the next route. If the entry page fails to load, report a Critical error and halt.

### Performance

- **NFR-7:** Mock Analysis route crawling must complete within 300 seconds total for up to 20 routes (3 viewports each). The 15s per-route budget covers a single viewport at a time (routes are processed sequentially, viewports may be parallelized within a route). Keyboard navigation testing shares the per-route budget; if the budget is exceeded mid-extraction, the route completes with partial results and a Warning is logged. If the total 300s budget is exhausted, Mock Analysis completes with the routes gathered so far and logs a Warning with the count of routes skipped.
- **NFR-8:** The self-health gate (running all tests) must complete within the same timeout constraints as `/test` Step 4 (bounded by `max_fix_iterations` and per-test-type timeouts).

### Maintainability

- **NFR-9:** All TDD-specific artifacts are namespaced under `docs/tdd/<slug>/` and `.pipeline/tdd/<slug>/` to avoid collision with standard pipeline artifacts.
- **NFR-10:** The `tdd` config section uses the same documentation style as existing config sections: commented out by default, inline comments explaining each option, sensible defaults.

### Backward Compatibility

- **NFR-11:** Projects without a `tdd` config section must continue to work with `/fullpipeline` with zero changes. The `tdd` config section is only read by `/tdd-fullpipeline`.
- **NFR-12:** The pipeline config template addition is purely additive -- existing `pipeline.config.yaml` files without the `tdd` section are unaffected.

### Concurrency & Budget

- **NFR-13:** All critic subagents within a Ralph Loop iteration run concurrently (parallel), not sequentially. A full 8-stage TDD pipeline run on a medium-complexity feature should complete within 4 hours under normal LLM API conditions, excluding Gate 2 (manual mock app creation). The 4-hour budget covers all automated stages (Stages 1-8) excluding Gate 2 wait time (manual mock creation). This aligns with the measurement boundary: the `tdd_cycle_time_seconds` metric tracks Stage 4 to Stage 8 only; NFR-13 applies to the full automated span.

### Artifact Hygiene

- **NFR-14:** `.pipeline/tdd/` and `.pipeline/metrics/` directories are added to the project's `.gitignore` during pipeline initialization. Mock screenshots and metrics JSON files are not committed to version control unless the developer explicitly removes the gitignore entry.

## 9. Testing Strategy

| User Story | Structural | Notes |
|-----------|------------|-------|
| US-1 (Orchestrator) | Yes | Verify `tdd-fullpipeline.md` has 8 stage sections, gates, orchestrator state, error recovery |
| US-2 (PRD) | Yes | Verify Stage 1 references `req2prd.md` |
| US-3 (Design Brief) | Yes | Verify `tdd-design-brief.md` has user flow, component inventory, Mock App Requirements sections |
| US-4 (Mock Analysis) | Yes | Verify `tdd-mock-analysis.md` references Playwright, 3 viewports, DOM extraction, data-testid |
| US-5 (Test Plan) | Yes | Verify `tdd-test-plan.md` has TP-{N}, tiered specs, mandatory contract sections |
| US-6 (Dev Plan) | Yes | Verify contract negotiation gate, TP-{N} mapping, Tier 2 completion |
| US-7 (Develop Tests) | Yes | Verify blind agent context, self-health gate, tiered development |
| US-8 (Develop App) | Yes | Verify test adjustment taxonomy (Structural/Behavioral/Security), 20% threshold |
| US-9 (Validate) | Yes | Verify traceability matrix, metrics emission, regression check |
| US-10 (Complexity Gate) | Yes | Verify complexity assessment criteria documented in command file |
| US-11 (Config) | YAML validation | Verify `tdd` section exists with correct keys and defaults |
| US-12 (CI Strategy) | Yes | Verify CI skip convention documented, GitHub Actions examples present |
| US-13 (Docs) | Yes | Verify WORKFLOW.md and README.md updated with TDD references |
| US-14 (Tests) | Self | Tests validate themselves by passing `npm test` / `node --test` |

**Rationale:** This project produces pipeline instruction files (Markdown) and configuration templates (YAML), not runtime application code. The primary automated validation is structural tests that assert expected content exists in the correct files. No unit or integration tests apply because there is no executable code being written -- only pipeline instructions consumed by LLM agents.

**Manual verification checklist:**
1. Run `/tdd-fullpipeline` on a medium-complexity frontend feature with a Figma AI mock app -- verify all 8 stages complete, self-health gate passes (all tests red), test adjustment taxonomy is enforced during Stage 7, and traceability matrix is generated in Stage 8.
2. Run `/tdd-fullpipeline` on a Simple-scope requirement -- verify complexity gate recommends `/fullpipeline`.
3. Verify `/fullpipeline` still works identically with no behavioral changes after TDD pipeline files are added.
4. Verify TDD artifacts are namespaced under `docs/tdd/<slug>/` and `.pipeline/tdd/<slug>/`.

### Tracking & Analytics Events

N/A -- the dev-pipeline is a CLI tool with no client-side tracking, analytics SDK, or telemetry. Pipeline metrics are emitted to `.pipeline/metrics/{slug}.json` for self-measurement, but these are local files, not analytics events.

## 10. Technical Context & Constraints

### Architecture

- **dev-pipeline** is a CLI pipeline tool (Claude Code plugin). It consists of Markdown instruction files consumed by LLM agents, YAML configuration templates, and JavaScript structural tests.
- There is no runtime application server, database, or API. Changes are to pipeline instruction documents, configuration templates, and test files.
- The pipeline itself is not a frontend project: `has_frontend: false`, `has_backend_service: false`, `has_api: false`.
- The `/tdd-fullpipeline` is a new parallel path, not a modification of the existing pipeline.

### Dependencies

- **Playwright** is required for Mock Analysis (Stage 3). It is a dependency of the target project, not of the pipeline itself. If Playwright is not available, Mock Analysis cannot run -- the pipeline must report this and halt (unlike `/fullpipeline` browser validation which falls back gracefully, Mock Analysis is not optional in the TDD pipeline because the UI contract is foundational to subsequent stages). Minimum supported Playwright version: 1.40. The `tdd-mock-analysis.md` command file verifies the installed version at Stage 3 start and halts with a clear error if the minimum is not met.
- **Figma AI** is an external tool used by the human at Gate 2. The pipeline does not integrate with Figma -- it produces a Design Brief document for manual handoff.

### Constraints

- All TDD command files follow the existing `.md` command pattern. No new patterns or conventions introduced.
- The orchestrator depth limit is the same as `/fullpipeline`: max 3 levels (orchestrator, stage subagent, build/review/critic subagent).
- Mock Analysis is the only stage that requires a running external application (the mock app). All other stages operate on files only.
- TDD artifacts are namespaced: `docs/tdd/<slug>/` for documents, `.pipeline/tdd/<slug>/` for screenshots and metrics.
- The test adjustment taxonomy is enforced by instructions in the command file, not by runtime code. The LLM agent classifies adjustments based on the taxonomy definitions.

### Files Created (new files)

1. `commands/tdd-fullpipeline.md` -- 8-stage orchestrator
2. `commands/tdd-design-brief.md` -- Design Brief generation (Stage 2)
3. `commands/tdd-mock-analysis.md` -- Mock Analysis via Playwright (Stage 3)
4. `commands/tdd-test-plan.md` -- Test Plan generation (Stage 4)
5. `commands/tdd-develop-tests.md` -- Tiered test development + self-health gate (Stage 6)

### Files Modified (existing files)

6. `pipeline/templates/pipeline-config-template.yaml` -- `tdd` config section (additive)
7. `WORKFLOW.md` -- TDD pipeline section (additive)
8. `README.md` -- Commands table update (additive)

### Files Created (P1)

9. `test/tdd-pipeline-structure.test.js` -- Structural validation tests

### Why no new command files for Stage 5, 7, 8

- **Stage 5 (Dev Plan):** Reuses the `/prd2plan` process with contract negotiation logic embedded in the `tdd-fullpipeline.md` orchestrator (between the `/prd2plan` subagent return and Gate 5).
- **Stage 7 (Develop App):** Reuses the `/execute` process. The test adjustment taxonomy is communicated to the `/execute` subagent via the subagent prompt in `tdd-fullpipeline.md`, not a separate command file.
- **Stage 8 (Validate):** Combines `/execute` Step 5 (smoke test) with `/test`-style cumulative validation. The traceability and metrics logic is embedded in the `tdd-fullpipeline.md` orchestrator's Stage 8 section.

## 11. Success Metrics

| Metric | Target | Measurement Method |
|--------|--------|--------------------|
| Self-health gate pass rate | 100% of TDD pipeline runs pass the self-health gate (red_count = total_test_count) on first attempt after test fixes | Count of runs where self-health gate passes vs total runs, from `.pipeline/metrics/{slug}.json` `red_test_count` |
| Test adjustment rate | Less than 15% behavioral test adjustments during Stage 7 (well below the 20% halt threshold) | `test_adjustment_count` metric in `.pipeline/metrics/{slug}.json`, broken down by type |
| Test plan accuracy | Greater than 85% of TP-{N} items pass without behavioral test adjustment | `test_plan_accuracy` metric in `.pipeline/metrics/{slug}.json` |
| Security test integrity | 100% of security tests never modified during Stage 7 | `security_test_integrity` metric in `.pipeline/metrics/{slug}.json` |
| Fake test detection | 0 fake tests pass the self-health gate undetected | Manual audit of self-health gate logs |
| Traceability completeness | 100% of TP-{N} items have a corresponding test file path and test name mapping | Traceability matrix in Stage 8 validation report |
| Pipeline completion rate | Greater than 80% of TDD pipeline runs reach Stage 8 (Validate) without user abort | Count of completed runs vs started runs |

### Metrics Schema

The `.pipeline/metrics/{slug}.json` file uses the following schema. Each pipeline run overwrites the file for the given slug (no append/accumulation). Metrics are written only after successful Stage 8 completion. Partial pipeline runs do NOT overwrite existing metrics. The previous run's metrics file is preserved as `{slug}.prev.json` before overwriting.

```json
{
  "schema_version": 1,
  "slug": "string",
  "timestamp": "ISO 8601",
  "red_test_count": 0,
  "total_test_count": 0,
  "green_pass_rate": 0.0,
  "test_adjustment_count": {
    "structural": 0,
    "behavioral": 0,
    "security_attempted": 0,
    "total": 0
  },
  "test_plan_accuracy": 0.0,
  "tdd_cycle_time_seconds": 0,
  "security_test_integrity": 0.0,
  "stages_completed": 0,
  "stages_total": 8
}
```

- `test_plan_accuracy`: percentage of TP-{N} items that passed without behavioral test adjustment (numerator: TP items with zero behavioral adjustments; denominator: total TP items).
- `tdd_cycle_time_seconds`: wall-clock elapsed time from Stage 4 (Test Plan) start to Stage 8 (Validate) completion.
- `security_test_integrity`: percentage of security-classified tests that were never modified during Stage 7 (numerator: unmodified security tests; denominator: total security-classified tests).

### Tracking & Analytics Events

N/A -- metrics measured via local `.pipeline/metrics/{slug}.json` files and manual pipeline run inspection. The dev-pipeline is a CLI tool with no client-side tracking, analytics SDK, or telemetry.

## 12. Open Questions

- [ ] **OQ-1:** Should the Design Brief include wireframe descriptions (text-based layout suggestions) or is pure functional specification sufficient for Figma AI to produce a good mock? Risk: too little guidance produces an unusable mock; too much guidance constrains the AI designer unnecessarily.
- [x] **OQ-2:** Resolved: Option (a) -- the Design Brief (Stage 2) must include a route manifest listing all expected routes. Mock Analysis (Stage 3) validates discovered routes against the manifest and flags missing routes as Warnings. Add route manifest to AC 3.2.
- [x] **OQ-3:** Resolved: Tier 2 integration/unit tests are specified in Stage 4 (Test Plan) but developed in Stage 7 (Develop App) alongside the application code, not in Stage 6. This avoids writing detailed integration tests against component internals that do not yet exist, which would cause excessive behavioral adjustments. Stage 6 develops only Tier 1 E2E tests. Update AC 5.3, AC 7.2, AC 7.3, FR-7 accordingly.
- [ ] **OQ-4:** What is the right threshold for the test adjustment halt? 20% is the initial proposal, but it should be validated against real TDD pipeline runs. Too low causes unnecessary halts; too high defeats the purpose.
- [x] **OQ-5:** Resolved: Semi-automated per AC 6.4 / AC 6.7 -- the pipeline presents conflicts and recommendations; the user decides.
- [x] **OQ-6:** Resolved: v1 targets frontend projects only (`has_frontend: true`). Non-frontend projects should use `/fullpipeline`. The Design Brief and Mock Analysis stages require a visual mock app, which is not applicable to CLI tools, APIs, or data pipelines. Future versions may add API contract analysis for non-frontend projects.

## 13. Dependencies & Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Mock app quality too low for meaningful UI contract extraction | High -- garbage-in-garbage-out: poor mock leads to poor test plan leads to poor tests | Medium -- Figma AI quality varies; Design Brief quality affects mock quality | Design Brief includes detailed functional requirements and Mock App Requirements section. Gate 3 allows user to correct extracted contracts. User can iterate on mock before proceeding. |
| Self-health gate false negatives (tests pass without app code due to default values, empty arrays, or trivial assertions) | High -- defeats the purpose of TDD pipeline | Low -- the gate explicitly checks red_count = total_test_count | Critic review of test code (Stage 6) specifically checks for trivial assertions. Fake test detection flags any passing test. |
| Test adjustment rate consistently exceeds 20% threshold | Medium -- pipeline halts frequently, reducing developer velocity | Medium -- first-time TDD adoption may have higher adjustment rates as teams learn | Configurable threshold (`max_test_adjustment_pct`). Initial runs may need higher threshold. Structural adjustments (import paths) are auto-approved and do not count toward behavioral adjustment limit. |
| Contract negotiation gate conflicts are too frequent or too complex for automated resolution | Medium -- slows pipeline; user fatigue from constant conflict resolution | Medium -- depends on how well test plan and dev plan align naturally | Semi-automated: pipeline presents recommendations, user decides. Test plan authority is a default, not absolute -- user can override. |
| Playwright not installed on target project, blocking Mock Analysis | High -- Stage 3 cannot run, entire TDD pipeline blocked | Medium -- not all projects have Playwright | Clear error message at Stage 3 start with installation instructions. Unlike browser validation fallback, this is a hard requirement for TDD pipeline. |
| Pipeline too long (8 stages vs 5) reduces adoption | Medium -- developers avoid TDD pipeline due to time cost | Medium -- complexity gate mitigates for simple tasks, but medium tasks still take longer | Complexity gate routes simple tasks to `/fullpipeline`. Stages 2-3 (Design Brief + Mock Analysis) are the main additions; remaining stages are reordered existing capabilities. Pipeline metrics track `tdd_cycle_time` to identify optimization opportunities. |
| Gate 2 (manual mock app creation) breaks automation flow | Medium -- human in the loop adds latency and requires Figma AI proficiency | High -- this is an intentional manual step | Design Brief minimizes friction by providing complete functional spec. Future P2 work (automated Figma integration) would eliminate this manual step. |

## 14. Timeline Estimate

| Deliverable | Complexity | Estimated Effort |
|------------|-----------|-----------------|
| `commands/tdd-fullpipeline.md` (8-stage orchestrator) | Complex | 3-4 hours |
| `commands/tdd-design-brief.md` (Stage 2) | Medium | 1-2 hours |
| `commands/tdd-mock-analysis.md` (Stage 3) | Complex | 2-3 hours |
| `commands/tdd-test-plan.md` (Stage 4) | Complex | 2-3 hours |
| `commands/tdd-develop-tests.md` (Stage 6) | Complex | 2-3 hours |
| `pipeline-config-template.yaml` edits (tdd section) | Simple | 30 minutes |
| `WORKFLOW.md` edits (TDD section) | Medium | 1-2 hours |
| `README.md` edits | Simple | 30 minutes |
| `test/tdd-pipeline-structure.test.js` (P1) | Medium | 1-2 hours |
| **Total** | | **13-20 hours** |

**Phase 1 (Core P0):** `tdd-fullpipeline.md` + `tdd-design-brief.md` + `tdd-mock-analysis.md` + `tdd-test-plan.md` + `tdd-develop-tests.md`. Estimated: 3 implementation sessions.

**Phase 2 (P1):** Config template + WORKFLOW.md + README.md + CI strategy documentation. Estimated: 1 implementation session.

**Phase 3 (P1):** Structural validation tests. Estimated: 0.5 implementation session.

**Total estimate:** 4.5 implementation sessions (each session = one `/execute` pipeline run with critic review).
